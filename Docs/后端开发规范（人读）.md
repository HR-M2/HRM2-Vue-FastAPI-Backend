# HRM2 后端开发规范

> 本文档为开发者和 AI 编程助手提供代码编写的约束和建议，确保代码风格和架构一致性。

---

## 目录

1. [代码风格约定](#1-代码风格约定)
2. [分层架构规范](#2-分层架构规范)
3. [SQLModel 使用规范](#3-sqlmodel-使用规范)
4. [CRUD 编写规范](#4-crud-编写规范)
5. [API 路由规范](#5-api-路由规范)
6. [Agent 开发规范](#6-agent-开发规范)
7. [新模块开发流程](#7-新模块开发流程)

---

## 1. 代码风格约定

### 1.1 命名规则

| 类型 | 命名风格 | 示例 |
|------|----------|------|
| 变量、函数、参数 | `snake_case` | `candidate_name`, `get_by_id()` |
| 类名 | `PascalCase` | `PositionCreate`, `CRUDBase` |
| 常量 | `UPPER_SNAKE_CASE` | `TOTAL_AGENTS`, `DEFAULT_PAGE_SIZE` |
| 私有方法/变量 | `_snake_case` | `_fmt_rules()`, `_parse_content()` |
| 文件名 | `snake_case.py` | `ai_services.py`, `llm_client.py` |

### 1.2 注释风格

**模块级文档字符串**（必须）：
```python
"""
岗位模型模块 - SQLModel 版本

合并了 Model 和 Schema，减少代码重复
"""
```

**类文档字符串**（必须）：
```python
class CRUDPosition(CRUDBase[Position]):
    """
    岗位 CRUD 操作类
    
    通用方法直接使用基类：
    - get(db, id) - 按 ID 获取
    - get_multi(db, skip, limit) - 分页获取
    - create(db, obj_in) - 创建
    """
```

**函数文档字符串**（复杂逻辑时）：
```python
async def get_with_applications(self, db: AsyncSession, id: str) -> Optional[Position]:
    """获取岗位详情（含申请列表）- 需要 selectinload"""
```

**行内注释**（仅在必要时）：
```python
# 检查岗位名称是否已存在
existing = await position_crud.get_by_title(db, data.title)
```

### 1.3 导入顺序

遵循 **标准库 → 第三方库 → 本地模块** 的顺序，每组之间空一行：

```python
# 1. 标准库
from typing import Optional, List, TYPE_CHECKING
from datetime import datetime

# 2. 第三方库
from fastapi import APIRouter, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession
from sqlmodel import SQLModel, Field, Relationship

# 3. 本地模块
from app.core.database import get_db
from app.core.response import success_response, paged_response
from app.crud import position_crud
from app.models import PositionCreate, PositionUpdate, PositionResponse
```

### 1.4 类型注解

**所有函数必须有完整的类型注解**：

```python
# ✅ 推荐
async def get(self, db: AsyncSession, id: str) -> Optional[Position]:
    ...

# ❌ 不推荐
async def get(self, db, id):
    ...
```

**使用 `TYPE_CHECKING` 避免循环导入**：

```python
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .application import Application
```

---

## 2. 分层架构规范

### 2.1 项目结构

```
app/
├── api/v1/           # API 路由层
├── core/             # 核心模块（配置、数据库、响应、异常）
├── crud/             # 数据访问层
├── models/           # SQLModel 模型（Table + Schema）
└── agents/           # AI Agent 业务逻辑层
    └── prompts/      # YAML 格式的 Prompt 配置
```

### 2.2 各层职责

| 层级 | 职责 | 禁止事项 |
|------|------|----------|
| **API 层** | 路由定义、参数校验、响应包装、调用 CRUD | ❌ 不做复杂业务逻辑 |
| **CRUD 层** | 数据库增删改查操作 | ❌ 不做业务判断、不调用其他 CRUD |
| **Models 层** | 定义表结构和数据模式 | ❌ 不包含任何业务逻辑 |
| **Services 层** | 复杂业务逻辑（如 AI Agent 流程） | ❌ 不直接操作数据库（通过 CRUD） |
| **Core 层** | 配置、数据库连接、统一响应、异常定义 | ❌ 不包含业务代码 |

### 2.3 调用关系

```
API 层  →  CRUD 层  →  数据库
   ↓
Services 层（复杂业务时）
```

**规则**：
- API 层可以直接调用 CRUD 层
- 复杂业务逻辑放到 Services 层，API 层调用 Services
- CRUD 层之间**禁止**相互调用

---

## 3. SQLModel 使用规范

### 3.1 模型文件结构

每个业务模块的 Model 文件采用统一结构：

```python
"""
{模块名}模型模块 - SQLModel 版本
"""
from typing import Optional, List, TYPE_CHECKING
from sqlmodel import SQLModel, Field, Relationship, Column, JSON

from .base import SQLModelBase, TimestampMixin, IDMixin, TimestampResponse

if TYPE_CHECKING:
    from .related_model import RelatedModel


# ==================== 基础字段定义 ====================

class {Module}Base(SQLModelBase):
    """基础字段 - 用于创建和继承"""
    field1: str = Field(..., description="字段描述")
    field2: Optional[str] = Field(None, description="可选字段")


# ==================== 表模型 ====================

class {Module}({Module}Base, TimestampMixin, IDMixin, table=True):
    """表模型"""
    __tablename__ = "{modules}"
    
    # 仅表模型需要的字段
    extra_field: bool = Field(default=False, index=True)
    
    # 关联关系
    related_items: List["RelatedModel"] = Relationship(
        back_populates="{module}",
        sa_relationship_kwargs={"lazy": "selectin"}
    )


# ==================== 请求 Schema ====================

class {Module}Create({Module}Base):
    """创建请求"""
    pass  # 或添加创建时需要的额外字段


class {Module}Update(SQLModelBase):
    """更新请求 - 所有字段可选"""
    field1: Optional[str] = None
    field2: Optional[str] = None


# ==================== 响应 Schema ====================

class {Module}Response(TimestampResponse):
    """详情响应"""
    field1: str
    field2: Optional[str]
    # 可添加计算字段
    item_count: int = Field(0, description="关联数量")


class {Module}ListResponse(TimestampResponse):
    """列表项响应（简化版）"""
    field1: str
    # 仅包含列表需要显示的字段
```

### 3.2 基类使用

| 基类 | 用途 | 继承场景 |
|------|------|----------|
| `SQLModelBase` | 所有 Schema 的基类 | Create/Update/非表模型 |
| `TimestampMixin` | 添加 `created_at`, `updated_at` | 表模型 |
| `IDMixin` | 添加 UUID 主键 `id` | 表模型 |
| `TimestampResponse` | 响应基类（含 id + 时间戳） | Response Schema |

### 3.3 字段定义规范

```python
# 必填字段
title: str = Field(..., min_length=1, max_length=100, description="岗位名称", index=True)

# 可选字段
department: Optional[str] = Field(None, max_length=100, description="所属部门")

# 列表字段（存储为 JSON）
required_skills: List[str] = Field(default_factory=list, sa_column=Column(JSON), description="必备技能")

# 数值字段带约束
min_experience: int = Field(0, ge=0, description="最低工作年限")

# 布尔字段带索引
is_active: bool = Field(default=True, index=True, description="是否启用")
```

### 3.4 导出规范

在 `models/__init__.py` 中统一导出：

```python
from .{module} import {Module}, {Module}Create, {Module}Update, {Module}Response, {Module}ListResponse

__all__ = [
    # {Module}
    "{Module}",
    "{Module}Create",
    "{Module}Update",
    "{Module}Response",
    "{Module}ListResponse",
]
```

---

## 4. CRUD 编写规范

### 4.1 CRUD 文件结构

```python
"""
{模块} CRUD 操作 - SQLModel 简化版

只保留有价值的业务查询，通用 CRUD 直接使用基类方法
"""
from typing import Optional, List
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from app.models import {Module}
from .base import CRUDBase


class CRUD{Module}(CRUDBase[{Module}]):
    """
    {模块} CRUD 操作类
    
    通用方法直接使用基类：
    - get(db, id) - 按 ID 获取
    - get_multi(db, skip, limit) - 分页获取
    - count(db) - 计数
    - create(db, obj_in) - 创建
    - update(db, db_obj, obj_in) - 更新
    - delete(db, id) - 删除
    """
    
    # 仅添加业务特定的查询方法
    async def get_with_relations(self, db: AsyncSession, id: str) -> Optional[{Module}]:
        """获取详情（含关联数据）"""
        result = await db.execute(
            select(self.model)
            .options(selectinload(self.model.related_items))
            .where(self.model.id == id)
        )
        return result.scalar_one_or_none()
    
    async def get_by_unique_field(self, db: AsyncSession, value: str) -> Optional[{Module}]:
        """根据唯一字段查找"""
        result = await db.execute(
            select(self.model).where(self.model.unique_field == value)
        )
        return result.scalar_one_or_none()


# 创建单例实例
{module}_crud = CRUD{Module}({Module})
```

### 4.2 何时添加自定义方法

**需要自定义方法**：
- 需要 `selectinload` 加载关联数据
- 需要根据业务字段查询（如 `get_by_title`）
- 需要带条件的列表查询（如 `get_active`）
- 需要复杂的聚合查询

**不需要自定义方法**（使用基类）：
- 简单的 CRUD 操作
- 按 ID 查询/删除
- 无条件的分页列表

### 4.3 导出规范

在 `crud/__init__.py` 中导出单例：

```python
from .{module} import {module}_crud

__all__ = [
    "{module}_crud",
]
```

---

## 5. API 路由规范

### 5.1 路由文件结构

```python
"""
{模块}管理 API 路由
"""
from typing import Optional
from fastapi import APIRouter, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.database import get_db
from app.core.response import (
    success_response,
    paged_response,
    ResponseModel,
    PagedResponseModel,
    MessageResponse,
)
from app.core.exceptions import NotFoundException, ConflictException
from app.crud import {module}_crud
from app.models import (
    {Module}Create,
    {Module}Update,
    {Module}Response,
    {Module}ListResponse,
)

router = APIRouter()
```

### 5.2 路由命名规范

| 操作 | HTTP 方法 | 路径 | 函数名 |
|------|-----------|------|--------|
| 列表 | GET | `""` | `get_{modules}` |
| 创建 | POST | `""` | `create_{module}` |
| 详情 | GET | `"/{module}_id"` | `get_{module}` |
| 更新 | PATCH | `"/{module}_id"` | `update_{module}` |
| 删除 | DELETE | `"/{module}_id"` | `delete_{module}` |

### 5.3 响应格式规范

**列表响应**（使用 `paged_response`）：
```python
@router.get("", summary="获取列表", response_model=PagedResponseModel[{Module}ListResponse])
async def get_{modules}(
    page: int = Query(1, ge=1, description="页码"),
    page_size: int = Query(20, ge=1, le=100, description="每页数量"),
    db: AsyncSession = Depends(get_db),
):
    skip = (page - 1) * page_size
    items = await {module}_crud.get_multi(db, skip=skip, limit=page_size)
    total = await {module}_crud.count(db)
    
    return paged_response(
        [item.model_dump() for item in items],
        total, page, page_size
    )
```

**单条响应**（使用 `success_response`）：
```python
@router.get("/{id}", summary="获取详情", response_model=ResponseModel[{Module}Response])
async def get_{module}(id: str, db: AsyncSession = Depends(get_db)):
    item = await {module}_crud.get(db, id)
    if not item:
        raise NotFoundException(f"资源不存在: {id}")
    
    return success_response(data={Module}Response.model_validate(item).model_dump())
```

**仅消息响应**：
```python
@router.delete("/{id}", summary="删除", response_model=MessageResponse)
async def delete_{module}(id: str, db: AsyncSession = Depends(get_db)):
    item = await {module}_crud.get(db, id)
    if not item:
        raise NotFoundException(f"资源不存在: {id}")
    
    await {module}_crud.delete(db, id=id)
    return success_response(message="删除成功")
```

### 5.4 异常使用规范

| 异常类 | HTTP 状态码 | 使用场景 |
|--------|-------------|----------|
| `NotFoundException` | 404 | 资源不存在 |
| `BadRequestException` | 400 | 请求参数错误 |
| `ConflictException` | 409 | 资源冲突（如重复创建） |

```python
# 资源不存在
if not item:
    raise NotFoundException(f"岗位不存在: {position_id}")

# 资源冲突
if existing:
    raise ConflictException(f"岗位 '{data.title}' 已存在")
```

### 5.5 路由注册

在 `api/v1/__init__.py` 中注册：

```python
from .{module}s import router as {module}s_router

api_router.include_router({module}s_router, prefix="/{modules}", tags=["{模块}管理"])
```

---

## 6. Agent 开发规范

### 6.1 目录结构

```
app/agents/
├── __init__.py          # 统一导出
├── base.py              # BaseAgentManager 基类
├── llm_client.py        # LLM 客户端封装
├── prompts/             # Prompt 配置目录
│   ├── __init__.py      # 导出 get_prompt, get_config
│   ├── loader.py        # PromptLoader 实现
│   ├── screening.yaml   # 筛选流程 prompts
│   ├── interview.yaml   # 面试流程 prompts
│   ├── analysis.yaml    # 分析流程 prompts + 配置
│   ├── position.yaml    # 岗位生成 prompts
│   └── dev_tools.yaml   # 开发工具 prompts
├── screening.py         # 筛选 Agent
├── interview.py         # 面试 Agent
├── analysis.py          # 分析 Agent
├── position.py          # 岗位 Agent
└── dev_tools.py         # 开发工具
```

### 6.2 Prompt 管理（YAML 分离模式）

**设计原则**：
- Prompts 与业务代码分离，便于维护和版本管理
- 支持模板变量替换，兼容 `.format()` 语法
- 内置缓存机制，生产环境无性能损耗

**YAML 文件格式**：

```yaml
# prompts/screening.yaml

# 系统提示
hr_system: |
  你是企业HR专家，专注于人才的综合素质评估。请根据以下标准进行评分：
  {hr_rules}
  
  评分要点：
  1. 工作经验匹配度
  2. 学历背景和证书资质
  ...

# 配置项（非 prompt）
evaluation_dimensions:
  professional_competency:
    name: "专业能力"
    weight: 0.30
    sub_dimensions:
      - "核心技能掌握程度"
      - "专业知识深度"
```

**在 Agent 中使用**：

```python
from .prompts import get_prompt, get_config

# 获取并格式化 prompt
system_message = get_prompt(
    "screening", "hr_system",
    hr_rules=json.dumps(rules, ensure_ascii=False)
)

# 获取配置项
dimensions = get_config("analysis", "evaluation_dimensions")
```

### 6.3 Agent 文件结构

```python
"""
{功能} Agent 流程。
"""
import json
from typing import Any, Dict, List, Optional

import autogen
from autogen import AssistantAgent, UserProxyAgent, GroupChat

from .base import BaseAgentManager
from .llm_client import get_llm_client
from .prompts import get_prompt


# ---------------------- 规则生成 ----------------------

def generate_scoring_rules(criteria: Dict[str, Any]) -> Dict[str, List]:
    """根据条件生成评分规则"""
    ...


# ---------------------- 代理创建 ----------------------

def create_{function}_agents(criteria: Dict[str, Any]) -> List[autogen.Agent]:
    """根据条件创建代理"""
    llm_config = get_llm_client().get_autogen_config()
    
    hr_agent = AssistantAgent(
        name="HR_Expert",
        llm_config=llm_config,
        system_message=get_prompt("screening", "hr_system", hr_rules=...),
    )
    ...


# ---------------------- 管理器实现 ----------------------

class {Function}AgentManager(BaseAgentManager):
    """{功能} Agent 管理器"""
    
    def __init__(self, criteria: Dict[str, Any]):
        super().__init__(criteria)
        self.weights = {"agent1": 0.3, "agent2": 0.4, "agent3": 0.3}
    
    def setup(self):
        """创建代理与群聊"""
        ...
    
    def run_{function}(self, input_data: str) -> List[Dict]:
        """运行流程，返回对话消息列表"""
        ...
```

### 6.4 添加新 Prompt 的流程

1. **编辑 YAML 文件**：在对应的 `prompts/*.yaml` 中添加新的 prompt 键
2. **在代码中调用**：使用 `get_prompt("文件名", "键名", 变量=值)`
3. **无需重启**：开发环境支持热加载，修改 YAML 后立即生效

### 6.5 继承 BaseAgentManager

```python
class MyAgentManager(BaseAgentManager):
    def __init__(self, criteria: Dict[str, Any]):
        super().__init__(criteria)
        # 初始化特定属性
    
    def setup(self):
        # 1. 创建代理列表
        agents = create_my_agents(self.criteria)
        
        # 2. 定义发言人选择器
        def speaker_selector(last_speaker, groupchat):
            ...
        
        # 3. 创建群聊
        self.create_group_chat(agents, speaker_selector)
        
        # 4. 创建管理器
        system_message = get_prompt("my_agent", "manager_prompt", ...)
        self.create_manager(system_message=system_message)
    
    def run_process(self, input_data: str) -> List[Dict]:
        if not self.manager:
            self.setup()
        
        return self.run_chat(self.agents[0], message=input_data)
```

---

## 7. 新模块开发流程

以添加新业务模块 `{Module}` 为例：

### Step 1: 创建 Model

创建 `app/models/{module}.py`：

```python
"""
{模块}模型模块 - SQLModel 版本
"""
# 按照 SQLModel 使用规范 创建 Base → Table → Create/Update/Response
```

在 `app/models/__init__.py` 中添加导出：

```python
from .{module} import {Module}, {Module}Create, {Module}Update, {Module}Response, {Module}ListResponse

__all__ = [
    # 添加到列表
    "{Module}",
    "{Module}Create",
    ...
]
```

### Step 2: 创建 CRUD

创建 `app/crud/{module}.py`：

```python
"""
{模块} CRUD 操作
"""
# 按照 CRUD 编写规范 继承 CRUDBase，添加业务方法

{module}_crud = CRUD{Module}({Module})
```

在 `app/crud/__init__.py` 中添加导出：

```python
from .{module} import {module}_crud

__all__ = [
    "{module}_crud",
]
```

### Step 3: 创建 API 路由

创建 `app/api/v1/{modules}.py`：

```python
"""
{模块}管理 API 路由
"""
# 按照 API 路由规范 实现 CRUD 端点

router = APIRouter()
```

在 `app/api/v1/__init__.py` 中注册路由：

```python
from .{modules} import router as {modules}_router

api_router.include_router({modules}_router, prefix="/{modules}", tags=["{模块}管理"])
```

### Step 4: 验证

1. 启动服务：`python run.py`
2. 访问 Swagger UI：`http://127.0.0.1:8000/docs`
3. 测试所有 CRUD 端点

### Step 5: （可选）添加 Agent

如果需要 AI 功能，创建 `app/services/agents/{module}.py`：

```python
"""
{模块} Agent 流程
"""
# 按照 Agent 开发规范 实现
```

在 `app/services/agents/__init__.py` 中导出。

---

## 附录：常用代码片段

### 分页查询模板

```python
@router.get("", response_model=PagedResponseModel[ItemListResponse])
async def get_items(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    db: AsyncSession = Depends(get_db),
):
    skip = (page - 1) * page_size
    items = await item_crud.get_multi(db, skip=skip, limit=page_size)
    total = await item_crud.count(db)
    
    return paged_response(
        [ItemListResponse.model_validate(i).model_dump() for i in items],
        total, page, page_size
    )
```

### 带关联的详情查询模板

```python
@router.get("/{id}", response_model=ResponseModel[ItemResponse])
async def get_item(id: str, db: AsyncSession = Depends(get_db)):
    item = await item_crud.get_with_relations(db, id)
    if not item:
        raise NotFoundException(f"资源不存在: {id}")
    
    response = ItemResponse.model_validate(item)
    response.related_count = len(item.related_items) if item.related_items else 0
    
    return success_response(data=response.model_dump())
```

### 创建前检查唯一性模板

```python
@router.post("", response_model=ResponseModel[ItemResponse])
async def create_item(data: ItemCreate, db: AsyncSession = Depends(get_db)):
    existing = await item_crud.get_by_unique_field(db, data.unique_field)
    if existing:
        raise ConflictException(f"'{data.unique_field}' 已存在")
    
    item = await item_crud.create(db, obj_in=data)
    return success_response(
        data=ItemResponse.model_validate(item).model_dump(),
        message="创建成功"
    )
```

---

> 📝 **维护说明**：本文档随项目架构演进而更新。如有疑问或建议，请及时反馈。
